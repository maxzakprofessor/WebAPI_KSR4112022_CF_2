using Microsoft.EntityFrameworkCore;
using Microsoft.Extensions.Options;
using WebAPI_KSR4112022_CF_2.Models;

//Подготовка инструментов (builder): Программа берет «чемодан с инструментами» для создания веб-приложения.
var builder = WebApplication.CreateBuilder(args);

// Add services to the container.

builder.Services.AddControllers();
// Learn more about configuring Swagger/OpenAPI at https://aka.ms/aspnetcore/swashbuckle
builder.Services.AddEndpointsApiExplorer();

//Визуальная документация(Swagger): Включается специальная страница, где вы (разработчик) сможете увидеть список всех запросов,
//которые понимает сервер, и потыкать их кнопочками.
builder.Services.AddSwaggerGen();

//Настройка базы данных: Код находит адрес вашей базы данных (в данном случае это легкая база SQLite) и говорит приложению:
//«Все данные храни и бери оттуда». Там же закомментированы варианты для PostgreSQL и SQL Server на будущее.
var connectionString = builder.Configuration.GetConnectionString("SqliteConnection");
builder.Services.AddDbContext<AppDbContext>(options =>
//options.UseNpgsql(connectionString));
//options.UseSqlServer(connectionString));
options.UseSqlite(connectionString));

//Открытость для мира (CORS): Код разрешает любым сайтам (WithOrigins("*")) обращаться к этому серверу. Это как убрать забор перед входом, чтобы любой браузер мог достучаться до данных.
builder.Services.AddCors(p => p.AddPolicy("corspolicy", build =>
{
    build.WithOrigins("*").AllowAnyMethod().AllowAnyHeader();
}));

var app = builder.Build();


// Configure the HTTP request pipeline.
//if (app.Environment.IsDevelopment())
//{
    app.UseSwagger();
    app.UseSwaggerUI();
//}

/*
 * Безопасность и правила: Устанавливается защита (HTTPS)
 * Эта строчка активирует «разрешение на вход» для сторонних ресурсов.
Если объяснять «на пальцах»:
Представьте, что ваш сервер — это закрытый клуб. По умолчанию браузеры (из соображений безопасности) 
запрещают сайтам с одного адреса (например, my-site.com) брать данные с сервера на другом адресе (my-api.com). 
Это называется политикой SOP (Same Origin Policy).
Команда app.UseCors("corspolicy") говорит серверу:
«Используй правило под названием "corspolicy", которое мы прописали выше. Согласно ему, 
мы доверяем всем (WithOrigins("*")) и разрешаем им запрашивать данные».
Зачем это нужно в вашем коде:
Без этой строки, если вы попытаетесь обратиться к этому API из браузера 
(например, через React, Vue или обычный JS), браузер заблокирует ответ, и вы увидите ошибку в консоли.
Хотите
*/
app.UseCors("corspolicy");

/*Безопасность и правила: Устанавливается защита (HTTPS).
 Эта строчка работает как строгий швейцар, который перенаправляет всех посетителей с опасного входа на безопасный. [1, 2]
На пальцах:
Есть протокол HTTP (незащищенный) и HTTPS (защищенный, с шифрованием). [2]
Если пользователь случайно введет адрес вашего сайта через http://, команда app.UseHttpsRedirection() автоматически 
«схватит» его и перекинет на тот же адрес, но уже через безопасный https://. [2, 3]
Зачем это нужно:
Чтобы данные между браузером и вашим сервером (например, пароли или данные из базы SQLite) передавались в зашифрованном 
виде и их нельзя было перехватить по пути. [2]
В вашем коде эта команда стоит перед обработкой запросов, чтобы безопасность обеспечивалась с самого начала сессии. [2, 3]*/
app.UseHttpsRedirection();

/*Безопасность и правила: правила авторизации.
 Эта строчка — «проверка пропусков» у тех, кто уже вошел в здание.
Если UseHttpsRedirection — это безопасный вход, то UseAuthorization — это охранник внутри, который проверяет: 
«А есть ли у тебя права находиться именно в этой комнате?»
На пальцах:
Аутентификация (обычно идет перед этим) — это проверка паспорта: «Ты тот, за кого себя выдаешь?».
Авторизация (UseAuthorization) — это проверка уровня доступа: «Ты обычный гость или администратор? Тебе можно 
только смотреть на товары или ты можешь их удалять?».
Важный нюанс:
В вашем коде эта команда стоит стандартным «заборчиком». Она подготавливает сервер к тому, 
что если вы в будущем повесите на какой-то контроллер или метод ярлык [Authorize], 
программа автоматически проверит права пользователя перед тем, как пустить его внутрь.*/
app.UseAuthorization();
/*Безопасность и правила: способ обработки ссылок (контроллеры).
Эта строчка — «диспетчерская вышка», которая связывает адрес в браузере с конкретным куском вашего кода.
На пальцах:
Представьте, что ваш сервер — это большой офис с множеством отделов. Когда клиент присылает запрос (например, 
GET /api/users), серверу нужно понять, в какой именно кабинет этот запрос отправить.
Что конкретно делает app.MapControllers():
Она сканирует ваше приложение в поисках классов-контроллеров (тех, что помечены атрибутом [ApiController]).
Она считывает «маршруты» (адреса), которые вы прописали внутри этих контроллеров (например, [Route("api/[controller]")]).
Она создает карту дорог: «Если пришел запрос по такому-то адресу — вызывай вот эту функцию».
Без этой команды ваш сервер будет работать, база данных будет подключена, но на любой запрос извне он ответит: «404 Not Found», 
потому что он просто не будет знать, какой контроллер за какой адрес отвечает.
*/
app.MapControllers();

/*
 Это финальный рубильник. Она запускает всё то, что вы «настроили» строчками выше.
На пальцах:
До этой команды ваш код — это просто список инструкций на бумаге. Вы объяснили программе, 
где база данных, как проверять пропуска и куда направлять запросы, но сервер всё ещё «спит».
Когда выполняется app.Run():
Сервер «просыпается» и начинает слушать входящий интернет-трафик.
Приложение переходит в режим бесконечного цикла: оно не закрывается само по себе, а ждет запросов от пользователей.
Если вы закроете консоль с запущенным приложением, это фактически нажмет «стоп» для этой команды.
Итог: это точка невозврата. Весь код до неё — это настройка, а после вызова app.Run() начинается реальная работа сервера.

 */
app.Run();
