using Microsoft.EntityFrameworkCore;
using Microsoft.Extensions.Options;
using WebAPI_KSR4112022_CF_2.Models;

//Подготовка инструментов (builder): Программа берет «чемодан с инструментами» для создания веб-приложения.
var builder = WebApplication.CreateBuilder(args);

// Add services to the container.

builder.Services.AddControllers();
// Learn more about configuring Swagger/OpenAPI at https://aka.ms/aspnetcore/swashbuckle
builder.Services.AddEndpointsApiExplorer();

//Визуальная документация(Swagger): Включается специальная страница, где вы (разработчик) сможете увидеть список всех запросов,
//которые понимает сервер, и потыкать их кнопочками.
builder.Services.AddSwaggerGen();

//Настройка базы данных: Код находит адрес вашей базы данных (в данном случае это легкая база SQLite) и говорит приложению:
//«Все данные храни и бери оттуда». Там же закомментированы варианты для PostgreSQL и SQL Server на будущее.
var connectionString = builder.Configuration.GetConnectionString("SqliteConnection");
builder.Services.AddDbContext<AppDbContext>(options =>
//options.UseNpgsql(connectionString));
//options.UseSqlServer(connectionString));
options.UseSqlite(connectionString));

// 1. Настройка политики
/*
Использовать WithOrigins("*") — это удобно для тестов, но у него есть подвох, который может сломать работу фронтенда в будущем.
Почему ваш вариант с * может не работать:
Безопасность (Credentials): Если ваш фронтенд будет отправлять Cookie или 
заголовки авторизации (Authorization: Bearer ...), браузер заблокирует запрос 
с *. Для работы с авторизацией в CORS обязательно нужно указывать конкретные домены.
Строгость браузеров: Современные браузеры иногда ведут себя капризно с "диким" 
CORS (*), если сайт работает по HTTPS (как ваш на Vercel).
Как сделать «по красоте» (рекомендуемый вариант):
Ваш код сейчас объявляет политику "corspolicy", но ее нужно еще и активировать.
*/
builder.Services.AddCors(options =>
{
    options.AddPolicy("corspolicy", policy =>
    {
        policy.WithOrigins(
                "https://drf-api-stock-vuu.vercel.app", // Ваш фронт на Vercel
                "http://localhost:5173",                // Локальный Vue
                "http://127.0.0.1:5173"
              )
              .AllowAnyMethod()
              .AllowAnyHeader()
              .AllowCredentials(); // Разрешает передачу токенов/куки (если понадобится)
    });
});

var app = builder.Build();


/*
Да, лучше оставить раскомментированным, как вы и сделали. Это правильное решение для этапа разработки и отладки на сервере Ubuntu.
Почему это хорошо:
Для отладки: Поскольку вы запускаете проект в Docker с параметром Production (или просто на удаленном сервере), Swagger поможет вам проверить, какие методы (GET/POST) вообще доступны и правильно ли они работают, не заглядывая в код.
Проверка путей: Вы сразу увидите, нужно ли добавлять /api/ в начало URL или нет.
Как теперь зайти в Swagger на Ubuntu:
После того как вы пересоберете и запустите контейнер, введите в браузере:
http://192.168.160.137
Важный нюанс (безопасность):
Когда вы закончите разработку и проект станет "боевым" (публичным для всех), Swagger лучше снова скрыть под if (app.Environment.IsDevelopment()), чтобы посторонние люди не видели структуру вашей базы данных и методов API. Но сейчас — оставляйте открытым.
*/


// Configure the HTTP request pipeline.
//if (app.Environment.IsDevelopment())
//{
    app.UseSwagger();
    app.UseSwaggerUI();
//}

/*
 * Безопасность и правила: Устанавливается защита (HTTPS)
 * Эта строчка активирует «разрешение на вход» для сторонних ресурсов.
Если объяснять «на пальцах»:
Представьте, что ваш сервер — это закрытый клуб. По умолчанию браузеры (из соображений безопасности) 
запрещают сайтам с одного адреса (например, my-site.com) брать данные с сервера на другом адресе (my-api.com). 
Это называется политикой SOP (Same Origin Policy).
Команда app.UseCors("corspolicy") говорит серверу:
«Используй правило под названием "corspolicy", которое мы прописали выше. Согласно ему, 
мы доверяем всем (WithOrigins("*")) и разрешаем им запрашивать данные».
Зачем это нужно в вашем коде:
Без этой строки, если вы попытаетесь обратиться к этому API из браузера 
(например, через React, Vue или обычный JS), браузер заблокирует ответ, и вы увидите ошибку в консоли.
Хотите
*/
app.UseCors("corspolicy");

/*Безопасность и правила: Устанавливается защита (HTTPS).
 Эта строчка работает как строгий швейцар, который перенаправляет всех посетителей с опасного входа на безопасный. [1, 2]
На пальцах:
Есть протокол HTTP (незащищенный) и HTTPS (защищенный, с шифрованием). [2]
Если пользователь случайно введет адрес вашего сайта через http://, команда app.UseHttpsRedirection() автоматически 
«схватит» его и перекинет на тот же адрес, но уже через безопасный https://. [2, 3]
Зачем это нужно:
Чтобы данные между браузером и вашим сервером (например, пароли или данные из базы SQLite) передавались в зашифрованном 
виде и их нельзя было перехватить по пути. [2]
В вашем коде эта команда стоит перед обработкой запросов, чтобы безопасность обеспечивалась с самого начала сессии. [2, 3]*/
app.UseHttpsRedirection();

/*Безопасность и правила: правила авторизации.
 Эта строчка — «проверка пропусков» у тех, кто уже вошел в здание.
Если UseHttpsRedirection — это безопасный вход, то UseAuthorization — это охранник внутри, который проверяет: 
«А есть ли у тебя права находиться именно в этой комнате?»
На пальцах:
Аутентификация (обычно идет перед этим) — это проверка паспорта: «Ты тот, за кого себя выдаешь?».
Авторизация (UseAuthorization) — это проверка уровня доступа: «Ты обычный гость или администратор? Тебе можно 
только смотреть на товары или ты можешь их удалять?».
Важный нюанс:
В вашем коде эта команда стоит стандартным «заборчиком». Она подготавливает сервер к тому, 
что если вы в будущем повесите на какой-то контроллер или метод ярлык [Authorize], 
программа автоматически проверит права пользователя перед тем, как пустить его внутрь.*/
app.UseAuthorization();
/*Безопасность и правила: способ обработки ссылок (контроллеры).
Эта строчка — «диспетчерская вышка», которая связывает адрес в браузере с конкретным куском вашего кода.
На пальцах:
Представьте, что ваш сервер — это большой офис с множеством отделов. Когда клиент присылает запрос (например, 
GET /api/users), серверу нужно понять, в какой именно кабинет этот запрос отправить.
Что конкретно делает app.MapControllers():
Она сканирует ваше приложение в поисках классов-контроллеров (тех, что помечены атрибутом [ApiController]).
Она считывает «маршруты» (адреса), которые вы прописали внутри этих контроллеров (например, [Route("api/[controller]")]).
Она создает карту дорог: «Если пришел запрос по такому-то адресу — вызывай вот эту функцию».
Без этой команды ваш сервер будет работать, база данных будет подключена, но на любой запрос извне он ответит: «404 Not Found», 
потому что он просто не будет знать, какой контроллер за какой адрес отвечает.
*/
app.MapControllers();

/*
 Это финальный рубильник. Она запускает всё то, что вы «настроили» строчками выше.
На пальцах:
До этой команды ваш код — это просто список инструкций на бумаге. Вы объяснили программе, 
где база данных, как проверять пропуска и куда направлять запросы, но сервер всё ещё «спит».
Когда выполняется app.Run():
Сервер «просыпается» и начинает слушать входящий интернет-трафик.
Приложение переходит в режим бесконечного цикла: оно не закрывается само по себе, а ждет запросов от пользователей.
Если вы закроете консоль с запущенным приложением, это фактически нажмет «стоп» для этой команды.
Итог: это точка невозврата. Весь код до неё — это настройка, а после вызова app.Run() начинается реальная работа сервера.

 */
app.Run();
